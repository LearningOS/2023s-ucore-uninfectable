# chapter4 练习

王哲威（[https://github.com/LearningOS/2023s-ucore-6ziv](https://github.com/LearningOS/2023s-ucore-6ziv)）

#### 编程作业1：重新实现sys_gettimeofday以及sys_task_info

首先先把chapter3的代码复制进来，实现sys_task_info。

这时需要重新实现的两个系统调用还不能正常运行，需要经过一次虚实地址转换。

我们定义宏`TRANSLATE_ADDR(TYPE,PTR)`，它等于这样的代码段：

```C
{
    struct proc *p = curr_proc();
    uint64 pa = useraddr(p->pagetable, (uint64)PTR);
    if (pa == 0)
        panic("bad address");
    PTR = (TYPE *)pa;
}
```

换言之，我们通过定义在`vm.h`中的函数`useraddr`，将传入系统调用的Virtual Address转换为对应的Physical Address。之后只要向其中填入需要返回的数据即可。

#### 编程作业2：mmap 匿名映射

我们新增了两个系统调用：`sys_mmap`和`sys_munmap`。先考虑前者的实现：

首先，我们完成一些必要的检查：`start`是否对齐页边界、`len`是否超过`1GiB`（`0x40000000`字节）的限制、`port`是否满足相关约束条件。

接下来，我们计算需要申请的页数：

`uint64 pages = (len + PGSIZE - 1) / PGSIZE;`

接下来循环进行每一页的申请。在循环中，先通过`kalloc`申请一个物理页，然后通过`mappages`函数建立页表项。其中，通过`translate_port(port)`函数来计算其`perm`参数，其定义为`(port << 1) | PTE_U`：将`port`的第0、1、2位(`R`,`W`,`X`)分别对应到`perm`的第1、2、3位（`PTE_R`,`PTE_W`,`PTE_X`）。

如果`kalloc`时出错，可能是因为物理内存不足。记循环变量为`j`，也就是说在出错之前已经成功建立了`j`个页表项。这个时候我们可以通过`uvmunmap`函数，取消从`start`地址开始的`j`个页的映射关系，并通过其最后一个参数`do_free`来释放内存：`uvmunmap`会调用`kfree`来进行释放。

如果`mappages`时出错，则在上述操作之外，还要把当前刚刚`kalloc`的一项也释放掉。

#### 问答题：

1.页表项由44位的地址和10位的标志位组成。

其中，地址为物理地址的高44位、标志位中有两位留供supervisor使用，其它八位分别表示`Dirty`,`Accessed`,`Global`,`User`,`Executable`,`Writable`,`Readable`,`Valid`。它们的意义如下：

`V`：页表项被使用

`R,W,X`：内存可读、可写、可执行。

`U`：内存可以被用户程序访问

`G`：所有程序都可以访问

`A`：读或写时都会设置为`1`，可以辅助系统判断内存替换策略。

`D`：内存内容被改动过，需要进行更新。

2.

- 请问哪些异常可能是缺页导致的？
  
  访存异常，程序执行取指异常？

- 发生缺页时，描述相关的重要寄存器的值
  
  `stvec`指向中断处理函数，`sscratch`指向`trapframe`，`satp`帮助在内核态进行地址转换。

- 这样做（Lazy策略）有哪些好处？
  
  比如说，程序很大，但是刚开始运行时只需要用到其中的一小部分，那么就可以先加载这一小部分进行运行，从而提高程序启动速度。
  
  同时，在用户程序的一次运行中，文件中可能有很多部分不会被用到。使用Lazy策略可以避免加载这些部分，从而节省运行时间。

- 请问处理 10G 连续的内存页面，需要操作的页表实际大致占用多少内存？
  
  大约10GB/512 = 20MB左右。

- 请简单思考如何才能在现有框架基础上实现 Lazy 策略，缺页时又如何处理？
  
  在页表项中额外记录它在硬盘/文件上对应的位置。在页面失效时，如果有`dirty`标志，则将内容写入到硬盘。
  
  缺页时触发相应中断处理函数，实际申请物理内存并将需要的页从磁盘加载到物理内存中。如果物理内存不足，则根据相应的替换策略选择被换出的页。

- 此时页面失效如何表现在页表项(PTE)上
  
  在页表中将对应的页表项里的物理地址设置为无效值。

3.

* 单页表情况下，如何更换页表？
  
  不更换。内核态与用户态共用同一张页表。
  
  在系统启动时，`OS`通过设置`satp`来从不使用页表的状态切换到使用页表的状态。

* 单页表情况下，如何控制用户态无法访问内核页面？
  
  利用`U`标志位，如果这一标志位没有被设置，则用户态被拒绝访问特定的页。

* 单页表有何优势？
  
  节约内存，而且效率较高（不需要同时操作两份页表）

* 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？
  
  进出内核态时更换页表。
  
  但是很多系统调用并不需要访问`kernel`独有的页表，因此我们可以选择由系统调用自己决定是否切换以及切换的时机。
